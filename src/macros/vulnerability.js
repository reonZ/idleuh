import { findItemWithSourceId, hasItemWithSourceId, socketEmit } from '../module'
import { getDcByLevel } from '../pf2e'
import { getEsotericSkill } from './shared/esoteric'

const effectUUID = 'Compendium.idleuh.effects.Item.MqgbuaqGMJ92VRze'
const targetUUID = 'Compendium.idleuh.effects.Item.Lz5hNf4dbXKjDWBa'
const mortalUUID = 'Compendium.idleuh.effects.Item.8BxBB5ztfRI9vFfZ'
const ffUUID = 'Compendium.pf2e.conditionitems.Item.AJh5ex99aV6VTggg'

export async function exploitVulnerability(event, actor, filterTypes) {
    if (event.ctrlKey) {
        if (game.user.isGM) cleanExploitVulnerabilityGM()
        else socketEmit({ type: 'clean-exploit-vulnerability' })
        ui.notifications.notify('All effects are being removed.')
        return
    }

    const targets = game.user.targets
    const [target] = targets
    const targetActor = target?.actor

    if (
        !actor ||
        !actor.isOwner ||
        !actor.isOfType('character') ||
        targets.size !== 1 ||
        !targetActor ||
        !targetActor.isOfType('creature')
    ) {
        ui.notifications.warn('You must select a character token you own and target another one.')
        return
    }

    const skill = getEsotericSkill(actor)
    if (!skill) return

    const actionSlug = 'action:recall-knowledge'
    const dc = getDcByLevel(targetActor)

    const extraRollOptions = actor.getRollOptions(['all', 'skill-check', 'Esoteric'])
    extraRollOptions.push(actionSlug)
    extraRollOptions.push(`secret`)

    const dv = targetActor.system.attributes.weaknesses
    const vulnerability = dv.reduce((prev, curr) => {
        if (curr.value > prev) return curr.value
        return prev
    }, 0)

    const weaknesses = dv.filter(x => x.value === vulnerability).map(x => x.type)

    const joinedWeaknessess = weaknesses.join(', ')

    const weaknessStr = joinedWeaknessess ? `<strong>[ ${joinedWeaknessess} ]</strong> = ${vulnerability}<br>` : ''

    const roll = await skill.roll({
        extraRollOptions,
        dc: { value: dc },
        rollMode: 'roll',
        label: `<span class="pf2-icon">A</span> <b>Exploit Vulnerability</b> <span">(Esoteric Check)</span>`,
        extraRollNotes: [
            {
                outcome: ['criticalFailure'],
                text: `<strong>Critical Failure</strong> You couldn't remember the right object to use and become distracted while you rummage through your esoterica. You become flat-footed until the beginning of your next turn.`,
            },
            {
                outcome: ['failure'],
                text: `<strong>Failure</strong> Failing to recall a salient weakness about the creature, you instead attempt to exploit a more personal vulnerability. You can exploit only the creature's personal antithesis. Your unarmed and weapon Strikes against the creature also become magical if they weren't already.`,
            },
            {
                outcome: ['success'],
                text: `${weaknessStr}<strong>Success</strong> You recall an important fact about the creature, learning its highest weakness (or one of its highest weaknesses, if it has multiple with the same value) but not its other weaknesses, resistances, or immunities. You can exploit either the creature's mortal weakness or personal antithesis. Your unarmed and weapon Strikes against the creature also become magical if they weren't already.`,
            },
            {
                outcome: ['criticalSuccess'],
                text: `${weaknessStr}<strong>Critical Success</strong> You remember the creature's weaknesses, and as you empower your esoterica, you have a flash of insight that grants even more knowledge about the creature. You learn all of the creature's resistances, weaknesses, and immunities, including the amounts of the resistances and weaknesses and any unusual weaknesses or vulnerabilities, such as what spells will pass through a golem's antimagic. You can exploit either the creature's mortal weakness or personal antithesis (see the Exploit Vulnerability class feature). Your unarmed and weapon Strikes against the creature also become magical if they weren't already.`,
            },
        ],
    })

    const success = roll.degreeOfSuccess

    const effect = findItemWithSourceId(actor, effectUUID, ['effect'])
    if (success >= 1 && !effect) {
        const data = (await fromUuid(effectUUID)).toObject()
        actor.createEmbeddedDocuments('Item', [data])
    } else if (success < 1) {
        effect?.delete()
        const flatEffect = hasItemWithSourceId(actor, ffUUID, ['condition'])
        if (!flatEffect) {
            const data = (await fromUuid(ffUUID)).toObject()
            actor.createEmbeddedDocuments('Item', [data])
        }
    }

    const filteredWeaknesses = weaknesses.filter(x => !filterTypes.includes(x))

    const packet = {
        type: 'exploit-vulnerability',
        actorId: actor.id,
        targetId: target.id,
        vulnerability: filteredWeaknesses.length ? vulnerability : 0,
        success,
    }

    if (game.user.isGM) exploitVulnerabilityGM(packet)
    else socketEmit(packet)
}

export async function exploitVulnerabilityGM({ actorId, targetId, vulnerability, success }) {
    const actor = game.actors.get(actorId)
    const targetActor = canvas.tokens.get(targetId)?.actor
    if (!actor || !targetActor) return

    const personal = 2 + Math.floor(actor.level / 2)
    const isMortal = success > 1 && vulnerability >= personal

    const mortalData = (await fromUuid(mortalUUID)).toObject()
    const rule = {
        key: 'Weakness',
        type: 'piercing',
        value: vulnerability,
        predicate: ['origin:effect:exploit-vulnerability'],
    }
    mortalData.system.rules.push(rule)

    for (const token of canvas.tokens.placeables) {
        const tokenActor = token.actor
        if (!tokenActor || tokenActor === actor) continue

        const targetEffect = findItemWithSourceId(tokenActor, targetUUID, ['effect'])
        const mortalsEffect = findItemWithSourceId(tokenActor, mortalUUID, ['effect'])

        await targetEffect?.delete()
        await mortalsEffect?.delete()

        if (success < 1) continue

        if (tokenActor === targetActor) {
            const data = (await fromUuid(targetUUID)).toObject()
            const rule = {
                key: 'Weakness',
                type: 'piercing',
                value: isMortal ? vulnerability : personal,
                predicate: ['origin:effect:exploit-vulnerability'],
            }
            data.system.rules.push(rule)
            tokenActor.createEmbeddedDocuments('Item', [data])
        } else if (isMortal && tokenActor.id === targetActor.id) {
            tokenActor.createEmbeddedDocuments('Item', [mortalData])
        }
    }
}

export function cleanExploitVulnerabilityGM() {
    for (const token of canvas.tokens.placeables) {
        const tokenActor = token.actor
        if (!tokenActor) continue

        const effect = findItemWithSourceId(tokenActor, effectUUID, ['effect'])
        const targetEffect = findItemWithSourceId(tokenActor, targetUUID, ['effect'])
        const mortalsEffect = findItemWithSourceId(tokenActor, mortalUUID, ['effect'])

        effect?.delete()
        targetEffect?.delete()
        mortalsEffect?.delete()
    }
}
