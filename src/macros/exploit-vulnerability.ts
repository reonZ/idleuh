import { socketEmit } from '@utils/socket'
import { findItemWithSourceId, hasItemWithSourceId } from '@utils/foundry/item'
import { esotericCheckTitle, getEsotericSkill, hasDiverseLore } from './shared/esoteric'

const effectUUID = 'Compendium.idleuh.effects.MqgbuaqGMJ92VRze'
const targetUUID = 'Compendium.idleuh.effects.Lz5hNf4dbXKjDWBa'
const mortalUUID = 'Compendium.idleuh.effects.8BxBB5ztfRI9vFfZ'
const ffUUID = 'Compendium.pf2e.conditionitems.AJh5ex99aV6VTggg'

export async function exploitVulnerability(event: JQuery.TriggeredEvent, actor: ActorPF2e, filterTypes: WeaknessType[]) {
    if (event.ctrlKey) {
        if (game.user.isGM) cleanExploitVulnerabilityGM()
        else socketEmit({ type: 'clean-exploit-vulnerability' })
        ui.notifications.notify('All effects are being removed.')
        return
    }

    const targets = game.user.targets as Set<TokenPF2e>
    const [target] = targets
    const targetActor = target?.actor

    if (
        !actor ||
        !actor.isOwner ||
        !actor.isOfType('character') ||
        targets.size !== 1 ||
        !targetActor ||
        !targetActor.isOfType('creature')
    ) {
        ui.notifications.warn('You must select a character token you own and target another one.')
        return
    }

    const skill = getEsotericSkill(actor)
    if (!skill) return

    const actionSlug = 'action:recall-knowledge'
    const DCbyLevel = [14, 15, 16, 18, 19, 20, 22, 23, 24, 26, 27, 28, 30, 31, 32, 34, 35, 36, 38, 39, 40, 42, 44, 46, 48, 50]
    const targetLevel = targetActor.system.details.level.value
    const dc = targetLevel < 0 ? 13 : DCbyLevel[targetLevel]!

    const options = actor.getRollOptions(['all', 'skill-check', 'Esoteric'])
    options.push(actionSlug)
    options.push(`secret`)

    const dv = targetActor.system.attributes.weaknesses
    const vulnerability = dv.reduce((prev, curr) => {
        if (curr.value > prev) return curr.value
        return prev
    }, 0)

    const weaknesses = dv.filter(x => x.value === vulnerability).map(x => x.type)

    const roll = (await game.pf2e.Check.roll(
        new game.pf2e.CheckModifier('test', skill),
        {
            actor,
            target: { actor: targetActor, token: target.document },
            title: esotericCheckTitle(),
            type: 'skill-check',
            options,
            dc: { value: dc },
            createMessage: false,
        },
        event
    ))!

    const result = roll.total ?? 0
    const die = roll.dice[0]?.total ?? 0
    const success = getSuccess(result, die, dc)

    const effect = findItemWithSourceId(actor, effectUUID, ['effect'])
    if (success >= 1 && !effect) {
        const data = (await fromUuid<EffectPF2e>(effectUUID))!.toObject()
        actor.createEmbeddedDocuments('Item', [data])
    } else if (success < 1) {
        effect?.delete()
        const flatEffect = hasItemWithSourceId(actor, ffUUID, ['condition'])
        if (!flatEffect) {
            const data = (await fromUuid<ConditionPF2e>(ffUUID))!.toObject()
            actor.createEmbeddedDocuments('Item', [data])
        }
    }

    createMsg(actor, targetActor, dc, result, die, success, vulnerability, weaknesses)

    const filteredWeaknesses = weaknesses.filter(x => !filterTypes.includes(x))

    const packet: ExploitVulnerabilityPacket = {
        type: 'exploit-vulnerability',
        actorId: actor.id,
        targetId: target.id,
        vulnerability: filteredWeaknesses.length ? vulnerability : 0,
        success,
    }

    if (game.user.isGM) exploitVulnerabilityGM(packet)
    else socketEmit(packet)
}

export async function exploitVulnerabilityGM({ actorId, targetId, vulnerability, success }: ExploitVulnerabilityPacket) {
    const actor = game.actors.get<CharacterPF2e>(actorId)
    const targetActor = canvas.tokens.get(targetId)?.actor as ActorPF2e | undefined | null
    if (!actor || !targetActor) return

    const personal = 2 + Math.floor(actor.level / 2)
    const isMortal = success > 1 && vulnerability >= personal

    const mortalData = (await fromUuid<EffectPF2e>(mortalUUID))!.toObject()
    const rule = {
        key: 'Weakness',
        type: 'piercing',
        value: vulnerability,
        predicate: ['origin:effect:exploit-vulnerability'],
    }
    mortalData.system.rules.push(rule)

    for (const token of canvas.tokens.placeables) {
        const tokenActor = token.actor as ActorPF2e
        if (!tokenActor || tokenActor === actor) continue

        const targetEffect = findItemWithSourceId(tokenActor, targetUUID, ['effect'])
        const mortalsEffect = findItemWithSourceId(tokenActor, mortalUUID, ['effect'])

        await targetEffect?.delete()
        await mortalsEffect?.delete()

        if (success < 1) continue

        if (tokenActor === targetActor) {
            const data = (await fromUuid<EffectPF2e>(targetUUID))!.toObject()
            const rule = {
                key: 'Weakness',
                type: 'piercing',
                value: isMortal ? vulnerability : personal,
                predicate: ['origin:effect:exploit-vulnerability'],
            }
            data.system.rules.push(rule)
            tokenActor.createEmbeddedDocuments('Item', [data])
        } else if (isMortal && tokenActor.id === targetActor.id) {
            tokenActor.createEmbeddedDocuments('Item', [mortalData])
        }
    }
}

export function cleanExploitVulnerabilityGM() {
    for (const token of canvas.tokens.placeables) {
        const tokenActor = token.actor as ActorPF2e
        if (!tokenActor) continue

        const effect = findItemWithSourceId(tokenActor, effectUUID, ['effect'])
        const targetEffect = findItemWithSourceId(tokenActor, targetUUID, ['effect'])
        const mortalsEffect = findItemWithSourceId(tokenActor, mortalUUID, ['effect'])

        effect?.delete()
        targetEffect?.delete()
        mortalsEffect?.delete()
    }
}

function getSuccess(total: number, die: number, dc: number) {
    let success = total >= dc + 10 ? 3 : total >= dc ? 2 : total > dc - 10 ? 1 : 0
    if (die === 20) success++
    else if (die === 1) success--
    return success
}

function createMsg(
    actor: CharacterPF2e,
    target: ActorPF2e,
    dc: number,
    result: number,
    die: number,
    success: number,
    vulnerability: number,
    weaknesses: string[]
) {
    const by = result - dc
    const mod = result - die
    const css = success >= 3 ? 'criticalSuccess' : success === 2 ? 'success' : success === 1 ? 'failure' : 'criticalFailure'
    const txt = success >= 3 ? 'Critical Success' : success === 2 ? 'Success' : success === 1 ? 'Failure' : 'Critical Failure'

    let flavor = `<h4 class="action"><span class="pf2-icon">A</span> <b>Exploit Vulnerability</b> <p class="compact-text">(Esoteric Check)</p></h4>
<div class="target-dc-result" data-visibility="gm">
    <div class="target-dc" data-visibility="gm"><span data-visibility="gm" data-whose="target">
        Target: ${target.name}</span> <span data-visibility="gm" data-whose="target">(Standard DC ${dc})</span></div>
    <div class="result degree-of-success" data-visibility="gm">
        Result: <span title="Roll: ${die} ${mod >= 0 ? '+' : '-'} ${Math.abs(mod)}">${result}</span> 
        <span data-whose="self" class="${css}">${txt}</span> <span data-whose="target">by ${by >= 0 ? '+' : ''}${by}</span>
    </div>
</div>`

    if (success >= 2 && weaknesses.length) {
        flavor += `<div><strong>[ ${weaknesses.join(', ')} ]</strong> = ${vulnerability}</div>`
    }

    flavor += '<section class="roll-note">'
    if (success >= 3) {
        flavor += `<strong>Critical Success</strong> You remember the creature's weaknesses, and as you empower your esoterica, 
you have a flash of insight that grants even more knowledge about the creature. 
You learn all of the creature's resistances, weaknesses, and immunities, 
including the amounts of the resistances and weaknesses and any unusual weaknesses or vulnerabilities, 
such as what spells will pass through a golem's antimagic. 
You can exploit either the creature's mortal weakness or personal antithesis (see the Exploit Vulnerability class feature). 
Your unarmed and weapon Strikes against the creature also become magical if they weren't already.`
    } else if (success === 2) {
        flavor += `<strong>Success</strong> You recall an important fact about the creature, 
learning its highest weakness (or one of its highest weaknesses, if it has multiple with the same value) but not its other weaknesses, 
resistances, or immunities. You can exploit either the creature's mortal weakness or personal antithesis. 
Your unarmed and weapon Strikes against the creature also become magical if they weren't already.`
    } else if (success === 1) {
        flavor += `<strong>Failure</strong> Failing to recall a salient weakness about the creature, 
you instead attempt to exploit a more personal vulnerability. 
You can exploit only the creature's personal antithesis. 
Your unarmed and weapon Strikes against the creature also become magical if they weren't already.`
    } else {
        flavor += `<strong>Critical Failure</strong> You couldn't remember the right object to use and become distracted while you rummage 
through your esoterica. You become flat-footed until the beginning of your next turn.`
    }
    flavor += '</section>'

    if (hasDiverseLore(actor) && success >= 2) flavor += getDiverseLoreMsg(target, result, die)

    ChatMessage.create({ flavor, actor })
}

function getDiverseLoreMsg(target: ActorPF2e, result: number, die: number) {
    const progression = (target as NPCPF2e).system.details.identification?.skill.progression ?? []
    const knowledges = progression.map(dc => {
        const success = getSuccess(result, die, dc)
        const color = success >= 3 ? 'green' : success === 2 ? 'blue' : '#ff4500'
        const title = success >= 3 ? 'Critical Success' : success === 2 ? 'Success' : 'Failure'
        return `<span style="color: ${color};" title="${title}">${dc}</span>`
    })
    const dcs = knowledges.length ? ` <span data-visibility="gm">${knowledges.join(', ')}</span>` : ''

    return `<section class="roll-note">
    <strong>Diverse Lore</strong> Compare the result of your Esoteric Lore check to the DC${dcs} to Recall Knowledge for that creature; 
    if that number would be a success or a critical success, you gain information as if you had succeeded at the Recall Knowledge check.
</section>`
}
