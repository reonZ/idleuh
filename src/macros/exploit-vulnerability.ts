import { socketEmit } from '~src/@utils/socket'
import { esotericCheckTitle, getEsotericSkill, hasDiverseLore } from './shared/esoteric'

const effectID = 'Item.bPm8eSVCrpYiWW2y'
const effectUUID = 'Compendium.idleuh.effects.MqgbuaqGMJ92VRze'
const ffUUID = 'Compendium.pf2e.conditionitems.AJh5ex99aV6VTggg'

export async function exploitVulnerability(event: JQuery.TriggeredEvent, actor: ActorPF2e) {
    const targets = game.user.targets as Set<TokenPF2e>
    const [target] = targets
    const targetActor = target?.actor

    if (!actor || !actor.isOwner || !actor.isOfType('character') || targets.size !== 1 || !targetActor) {
        ui.notifications.warn('You must select a character token you own and target another one.')
        return
    }

    const skill = getEsotericSkill(actor)
    if (!skill) return

    const actionSlug = 'action:recall-knowledge'
    const DCbyLevel = [14, 15, 16, 18, 19, 20, 22, 23, 24, 26, 27, 28, 30, 31, 32, 34, 35, 36, 38, 39, 40, 42, 44, 46, 48, 50]
    const targetLevel = targetActor.system.details.level.value
    const dc = targetLevel < 0 ? 13 : DCbyLevel[targetLevel]

    const options = actor.getRollOptions(['all', 'skill-check', 'Esoteric'])
    options.push(actionSlug)
    options.push(`secret`)

    const dv = targetActor.system.attributes.weaknesses
    const vulnerability = dv.reduce((prev, curr) => {
        if (curr.value > prev) return curr.value
        return prev
    }, 0)

    const roll = (await game.pf2e.Check.roll(
        new game.pf2e.CheckModifier('test', skill),
        {
            actor,
            target: { actor: targetActor, token: target.document },
            title: esotericCheckTitle(),
            type: 'skill-check',
            options,
            dc: { value: dc },
            createMessage: false,
        },
        event
    ))!

    const packet: ExploitVulnerabilityPacket = {
        type: 'exploit-vulnerability',
        actorId: actor.id,
        targetId: target.id,
        vulnerability,
        dc,
        total: roll.total ?? 0,
        die: roll.dice[0].total ?? 0,
    }

    if (game.user.isGM) exploitVulnerabilityGM(packet)
    else socketEmit(packet)
}

export async function exploitVulnerabilityGM({ actorId, targetId, vulnerability, dc, total, die }: ExploitVulnerabilityPacket) {
    const actor = game.actors.get<CharacterPF2e>(actorId)
    const targetActor = canvas.tokens.get(targetId)?.actor as ActorPF2e | undefined | null
    if (!actor || !targetActor) return

    const success = getSuccess(total, die, dc)

    canvas.tokens.placeables.forEach(token => {
        const tokenActor = token.actor as ActorPF2e
        if (!tokenActor || tokenActor === actor) return

        const effect = getEffect(tokenActor)

        if (tokenActor === targetActor) {
            if (success <= 0 && effect) effect.delete()
            else if (success >= 1 && !effect) addEffect(tokenActor)
        } else if (effect) {
            effect.delete()
        }
    })

    const effect = getEffect(actor)
    if (success >= 1) {
        const badge = (success >= 2 && vulnerability) || 1
        if (!effect) addEffect(actor, badge)
        else if (effect.badge?.value !== badge) effect.update({ 'system.badge.value': badge })
    } else {
        effect?.delete()
        addFlatFooted(actor)
    }

    createMsg(actor, targetActor, dc, total, die, success)
}

function getSuccess(total: number, die: number, dc: number) {
    let success = total >= dc + 10 ? 3 : total >= dc ? 2 : total > dc - 10 ? 1 : 0
    if (die === 20) success++
    else if (die === 1) success--
    return success
}

function createMsg(actor: CharacterPF2e, target: ActorPF2e, dc: number, total: number, die: number, success: number) {
    const by = total - dc
    const mod = total - die
    const css = success >= 3 ? 'criticalSuccess' : success === 2 ? 'success' : success === 1 ? 'failure' : 'criticalFailure'
    const txt = success >= 3 ? 'Critical Success' : success === 2 ? 'Success' : success === 1 ? 'Failure' : 'Critical Failure'

    let flavor = `<h4 class="action"><span class="pf2-icon">A</span> <b>Exploit Vulnerability</b> <p class="compact-text">(Esoteric Check)</p></h4>
<div class="target-dc-result" data-visibility="gm">
    <div class="target-dc" data-visibility="gm"><span data-visibility="gm" data-whose="target">
        Target: ${target.name}</span> <span data-visibility="gm" data-whose="target">(Standard DC ${dc})</span></div>
    <div class="result degree-of-success" data-visibility="gm">
        Result: <span title="Roll: ${die} ${mod >= 0 ? '+' : '-'} ${Math.abs(mod)}">${total}</span> 
        <span data-whose="self" class="${css}">${txt}</span> <span data-whose="target">by ${by >= 0 ? '+' : ''}${by}</span>
    </div>
</div>`

    flavor += '<section class="roll-note">'
    if (success >= 3) {
        flavor += `<strong>Critical Success</strong> You remember the creature's weaknesses, and as you empower your esoterica, 
you have a flash of insight that grants even more knowledge about the creature. 
You learn all of the creature's resistances, weaknesses, and immunities, 
including the amounts of the resistances and weaknesses and any unusual weaknesses or vulnerabilities, 
such as what spells will pass through a golem's antimagic. 
You can exploit either the creature's mortal weakness or personal antithesis (see the Exploit Vulnerability class feature). 
Your unarmed and weapon Strikes against the creature also become magical if they weren't already.`
    } else if (success === 2) {
        flavor += `<strong>Success</strong> You recall an important fact about the creature, 
learning its highest weakness (or one of its highest weaknesses, if it has multiple with the same value) but not its other weaknesses, 
resistances, or immunities. You can exploit either the creature's mortal weakness or personal antithesis. 
Your unarmed and weapon Strikes against the creature also become magical if they weren't already.`
    } else if (success === 1) {
        flavor += `<strong>Failure</strong> Failing to recall a salient weakness about the creature, 
you instead attempt to exploit a more personal vulnerability. 
You can exploit only the creature's personal antithesis. 
Your unarmed and weapon Strikes against the creature also become magical if they weren't already.`
    } else {
        flavor += `<strong>Critical Failure</strong> You couldn't remember the right object to use and become distracted while you rummage 
through your esoterica. You become flat-footed until the beginning of your next turn.`
    }
    flavor += '</section>'

    if (hasDiverseLore(actor) && success >= 2) flavor += getDiverseLoreMsg(target, total, die)

    ChatMessage.create({ flavor, actor })
}

function getDiverseLoreMsg(target: ActorPF2e, total: number, die: number) {
    const progression = (target as NPCPF2e).system.details.identification?.skill.progression ?? []
    const knowledges = progression.map(dc => {
        const success = getSuccess(total, die, dc)
        const color = success >= 3 ? 'green' : success === 2 ? 'blue' : '#ff4500'
        const title = success >= 3 ? 'Critical Success' : success === 2 ? 'Success' : 'Failure'
        return `<span style="color: ${color};" title="${title}">${dc}</span>`
    })
    const dcs = knowledges.length ? ` <span data-visibility="gm">${knowledges.join(', ')}</span>` : ''

    return `<section class="roll-note">
    <strong>Diverse Lore</strong> Compare the result of your Esoteric Lore check to the DC${dcs} to Recall Knowledge for that creature; 
    if that number would be a success or a critical success, you gain information as if you had succeeded at the Recall Knowledge check.
</section>`
}

function getEffect(actor: ActorPF2e) {
    return actor.itemTypes.effect.find(effect => effect.getFlag('core', 'sourceId') === effectID)
}

async function addEffect(actor: ActorPF2e, badge?: number) {
    const data = ((await fromUuid(effectUUID)) as EffectPF2e).toObject()
    if (badge) setProperty(data, 'system.badge.value', badge)
    actor.createEmbeddedDocuments('Item', [data])
}

async function addFlatFooted(actor: ActorPF2e) {
    const hasEffect = actor.itemTypes.condition.some(x => x.getFlag('core', 'sourceId') === ffUUID)
    if (hasEffect) return

    const data = ((await fromUuid(ffUUID)) as ConditionPF2e).toObject()
    actor.createEmbeddedDocuments('Item', [data])
}
