import { socketEmit } from '~src/@utils/socket'

const effectID = 'Item.bPm8eSVCrpYiWW2y'
const effectUUID = 'Compendium.idleuh.effects.MqgbuaqGMJ92VRze'
const ffUUID = 'Compendium.pf2e.conditionitems.AJh5ex99aV6VTggg'

export async function exploitVulnerability(event: JQuery.TriggeredEvent, actor: ActorPF2e) {
    const targets = game.user.targets as Set<TokenPF2e>
    const [target] = targets
    const targetActor = target?.actor

    if (!actor || !actor.isOwner || !actor.isOfType('character') || targets.size !== 1 || !targetActor) {
        ui.notifications.warn('You must select a character token you own and target another one.')
        return
    }

    const skillKeys = ['esoteric', 'esoteric-lore', 'lore-esoteric']
    const skill = Object.values(actor.system.skills).find(x => skillKeys.includes(x.slug))

    if (!skill) {
        ui.notifications.warn(`This character doesn't have the 'Esoteric' skill`)
        return
    }

    const actionSlug = 'action:recall-knowledge'
    const DCbyLevel = [14, 15, 16, 18, 19, 20, 22, 23, 24, 26, 27, 28, 30, 31, 32, 34, 35, 36, 38, 39, 40, 42, 44, 46, 48, 50]
    const targetLevel = targetActor.system.details.level.value
    const dc = targetLevel < 0 ? 13 : DCbyLevel[targetLevel]

    const options = actor.getRollOptions(['all', 'skill-check', 'Esoteric'])
    options.push(actionSlug)
    options.push(`secret`)

    const dv = targetActor.system.attributes.weaknesses
    const vulnerability = dv.reduce((prev, curr) => {
        if (curr.value > prev) return curr.value
        return prev
    }, 0)

    const roll = (await game.pf2e.Check.roll(
        new game.pf2e.CheckModifier('test', skill),
        {
            actor,
            target: { actor: targetActor, token: target.document },
            title: game.i18n.format('PF2E.SkillCheckWithName', { skillName: 'Esoteric' }),
            type: 'skill-check',
            options,
            dc: { value: dc },
            createMessage: false,
        },
        event
    ))!

    const total = roll.total ?? 0
    const success = getSuccess(roll, dc)

    const packet: ExploitVulnerabilityPacket = {
        type: 'exploit-vulnerability',
        actorId: actor.id,
        targetId: target.id,
        dc,
        success,
        total,
        vulnerability,
    }

    if (game.user.isGM) exploitVulnerabilityGM(packet)
    else socketEmit(packet)
}

export async function exploitVulnerabilityGM({
    actorId,
    targetId,
    success,
    vulnerability,
    dc,
    total,
}: ExploitVulnerabilityPacket) {
    const actor = game.actors.get<ActorPF2e>(actorId)
    const targetActor = canvas.tokens.get(targetId)?.actor as ActorPF2e | undefined | null
    if (!actor || !targetActor) return

    canvas.tokens.placeables.forEach(token => {
        const tokenActor = token.actor as ActorPF2e
        if (!tokenActor || tokenActor === actor) return

        const effect = getEffect(tokenActor)

        if (tokenActor === targetActor) {
            if (success <= 0 && effect) effect.delete()
            else if (success >= 1 && !effect) addEffect(tokenActor)
        } else if (effect) {
            effect.delete()
        }
    })

    const effect = getEffect(actor)
    if (success >= 1) {
        const badge = (success >= 2 && vulnerability) || 1
        if (!effect) addEffect(actor, badge)
        else if (effect.badge?.value !== badge) effect.update({ 'system.badge.value': badge })
    } else {
        effect?.delete()
        addFlatFooted(actor)
    }

    createMsg(actor, targetActor, dc, total, success)
}

function getSuccess(roll: Rolled<CheckRoll>, dc: number) {
    const total = roll.total!
    const die = roll.dice[0].total!

    let success = total >= dc + 10 ? 3 : total >= dc ? 2 : total > dc - 10 ? 1 : 0
    if (die === 20) success++
    else if (die === 1) success--

    return success
}

function createMsg(actor: ActorPF2e, target: ActorPF2e, dc: number, total: number, success: number) {
    const by = total - dc
    const css = success >= 3 ? 'criticalSuccess' : success === 2 ? 'success' : success === 1 ? 'failure' : 'criticalFailure'
    const txt = success >= 3 ? 'Critical Success' : success === 2 ? 'Success' : success === 1 ? 'Failure' : 'Critical Failure'

    let flavor = `<h4 class="action"><span class="pf2-icon">A</span> <b>Exploit Vulnerability</b> <p class="compact-text">(Esoteric Check)</p></h4>
<div class="target-dc-result" data-visibility="gm">
    <div class="target-dc" data-visibility="gm"><span data-visibility="gm" data-whose="target">
        Target: ${target.name}</span> <span data-visibility="gm" data-whose="target">(Standard DC ${dc})</span></div>
    <div class="result degree-of-success" data-visibility="gm">Result: 
        <span data-whose="self" class="${css}">${txt}</span> <span data-whose="target">by ${by >= 0 ? '+' : ''}${by}</span>
    </div>
</div>`

    if (success >= 3) {
        flavor += `<section class="roll-note">
    <strong>Critical Success</strong> You remember the creature's weaknesses, and as you empower your esoterica, 
    you have a flash of insight that grants even more knowledge about the creature. 
    You learn all of the creature's resistances, weaknesses, and immunities, 
    including the amounts of the resistances and weaknesses and any unusual weaknesses or vulnerabilities, 
    such as what spells will pass through a golem's antimagic. 
    You can exploit either the creature's mortal weakness or personal antithesis (see the Exploit Vulnerability class feature). 
    Your unarmed and weapon Strikes against the creature also become magical if they weren't already.
</section>`
    } else if (success === 2) {
        flavor += `<section class="roll-note">
    <strong>Success</strong> You recall an important fact about the creature, 
    learning its highest weakness (or one of its highest weaknesses, if it has multiple with the same value) but not its other weaknesses, 
    resistances, or immunities. You can exploit either the creature's mortal weakness or personal antithesis. 
    Your unarmed and weapon Strikes against the creature also become magical if they weren't already.
</section>`
    } else if (success === 1) {
        flavor += `<section class="roll-note">
    <strong>Failure</strong> Failing to recall a salient weakness about the creature, 
    you instead attempt to exploit a more personal vulnerability. 
    You can exploit only the creature's personal antithesis. 
    Your unarmed and weapon Strikes against the creature also become magical if they weren't already.
</section>`
    } else {
        flavor += `<section class="roll-note">
<strong>Critical Failure</strong> You couldn't remember the right object to use and become distracted while you rummage through your esoterica. 
You become flat-footed until the beginning of your next turn.
</section>`
    }

    ChatMessage.create({ flavor, actor })
}

function getEffect(actor: ActorPF2e) {
    return actor.itemTypes.effect.find(effect => effect.getFlag('core', 'sourceId') === effectID)
}

async function addEffect(actor: ActorPF2e, badge?: number) {
    const data = ((await fromUuid(effectUUID)) as EffectPF2e).toObject()
    if (badge) setProperty(data, 'system.badge.value', badge)
    actor.createEmbeddedDocuments('Item', [data])
}

async function addFlatFooted(actor: ActorPF2e) {
    const hasEffect = actor.itemTypes.condition.some(x => x.getFlag('core', 'sourceId') === ffUUID)
    if (hasEffect) return

    const data = ((await fromUuid(ffUUID)) as ConditionPF2e).toObject()
    actor.createEmbeddedDocuments('Item', [data])
}
